

struct data

	// all public
	int a:=5
	string s:="toast"
	// data* pdata:=nullptr // version 0.2

end


class student

	// default private or public or no default?
	public:

	ctor():= // ctor named ctor?
	end

	dtor():= // dtor named dtor?
	end

end


function main() :=

	// comment

	/* multiline
	   comment */

	\* multiline \* nestable *\ comment *\

	// assignment
	var a:=5 // auto
	val b:=3 // const auto
	// single "=" is never valid in order to avoid confusion between assignment and comparison
	var c:=7; var d:=8 // ";" and linebreak are equal
	var e:= ... // line continuation
		17

	if a<b then // do we actually need "then" and "do" and so on or do we just require \n or ; here?
		print(a, "<", b)
	elseif a==b then
		print(a, "==", b)
	else
		print(a, ">", b)
	end

	var f:= when e==17 then true else false // end? // ternary operator

	switch a
		case 1 do
			print("a is 1")
			// implicit break
		case 2 do
			print("a is 2")
			fall // prevents break
		default
			print("a is 2 or other")
	end

	while a<10 do
		a++
	end

	repeat
		a++
	until a==20 // end?

	repeat
		a++
	while a<30 // end? // can be distinguished from nested while loop by the lack of "do" (in case "do" stays, maybe rather use "whilst"?)

	for i<=5 do // 0 1 2 3 4 5
		print(i)
	end

	for 1<=i<5 do // 1 2 3 4
		print(i)
	end

	for 5>i>=0 do // 4 3 2 1 0
		print(i)
	end

	for 1<=i<10, i*=2 do // 1 2 4 8
		print(i)
	end

	for i in {2, 3, 5, 7, 11} do
		print(i)
	end

end

function fun0 end

function fun1 :=
end

function fun2() :=
end

function fun3(int x) :=
end

function fun4(int x:=0) :=
end

function fun5(int x:=0, int y) :=
end

function fun6 -> (int q) :=
end

function fun7 -> (int q:=0) :=
end

function fun8 -> (int q:=0, int r) :=
	val r:=5
	return q, r
end

function fun9 -> (int q:=0, int r:=7) :=
	// implicit return q, r in the end when all return values are initialized
end

function fun10(int x:=0, int y) -> (int q:=0, int r) :=
end

/*

operator precedence:

associat.   operator description
--------------------------------------------------------
left        ::       scope resolution
--------------------------------------------------------
left        a++      postfix increment
            a--      postfix decrement
            a()      call
            a[]      subscript
            .        member access
            ->       member access
--------------------------------------------------------
right       ++a      prefix increment
            --a      prefix decrement
            +a       unary plus
            -a       unary minus
            not      logical not
            bitnot   bitwise not
            (type)   c-style cast
            *a       dereference
            &a       address-of
            sizeof   size-of
            new      dynamic memory allocation
            new[]    dynamic memory array allocation
            delete   dynamic memory deallocation
            delete[] dynamic memory array deallocation
--------------------------------------------------------
left        .*       pointer-to-member
            ->*      pointer-to-member
--------------------------------------------------------
left        ^        exponentiation
--------------------------------------------------------
left        a*b      multiplication
            a/b      division
            a mod b  remainder
--------------------------------------------------------
left        a+b      addition
            a-b      subtraction
--------------------------------------------------------
left        shl      shift left
            shr      shift right
--------------------------------------------------------
left        bitand   bitwise and
--------------------------------------------------------
left        bitxor   bitwise xor
--------------------------------------------------------
left        bitor    bitwise or
--------------------------------------------------------
left        ==       equal
            !=       not equal
            <        lower than
            <=       lower or equal
            >        greater than
            >=       greater than or equal
--------------------------------------------------------
left        and      logical and
--------------------------------------------------------
left        or       logical or
--------------------------------------------------------
right       when     ternary conditional
            throw    throw operator
--------------------------------------------------------

assignments aren't operators

direct assignment
:=

compound assignment works with any infix operator
a @= b  translates to  a := a @ b

*/
